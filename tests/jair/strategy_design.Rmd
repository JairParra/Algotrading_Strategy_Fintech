---
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[CO,CE]{Hair Parra}
  - \fancyfoot[CO,CE]{Notes by Hair Parra}
  - \fancyfoot[LE,RO]{\thepage}
title: "Strategy Design (ML Fin Data - Project 1)"
author: "Hair Albeiro Parra Barrera"
geometry: margin=1.3cm
always_allow_html: true
output: 
    pdf_document: 
      extra_dependencies: ["array", "amsmath","booktabs"]
---

\newtheorem{assumption}{Assumption}[assumption]
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\newtheorem{remark*}{Remark}
\newtheorem{aside*}{Aside}
\newtheorem{exercise*}{Exercise}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=6) 

# configurations for plot 
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)
```

## Libraries 

```{r, echo=FALSE, message=FALSE}
# Load the required packages
library(TTR) 
library(here)
library(rvest)
library(dplyr)
library(quantmod)
library(tidyverse)
library(tidyquant)
```


# 0. Scraping the SP500

In order to test the logic within the strategy, I have fetched functions that retrieve a number of sample stocks by sector from the SP500. 

```{r}
# to obtain relative paths
library(here)

# Load code into environment 
source(here("functions", "fetch_sp500_sectors.R"))
```


### 0.0.1 SP500 Economic Sectors

The following function fetches and extract the economic sectors from the SP500, taken from [Wikipedia](https://en.wikipedia.org/wiki/List_of_S%26P_500_companies). 


```{r, message=FALSE}
# fetch the sectors as a dataframe 
sp500_sectors <- f_get_sp500_sectors()
head(sp500_sectors)
```


### 0.0.2 SP500 Sector Weight


```{r}
# wrap into a single argument funciton 
fetch_sp500_sector_data <- function(x){f_fetch_sector_data(x, sp500, sp500_sectors)}

# call the function 
head(fetch_sp500_sector_data("Information Technology"))
```

### 0.0.3 Retrieving top sectors and stocks 

Pack everything into one function to retrieve all the data 

```{r, message=FALSE, warning=FALSE}
# Retrieve top 10 stocks by weight for each sector in the top 5 sectors from the SP500 (by weight)
sector_list <- f_retrieve_top_sp500(top_n_sectors = 6, top_n_stocks = 15, only_tickers=TRUE)
sector_list
```
This logic is implemented under **functions/fetch_sp500_sectors.R**


### 0.0.4 Retrieving top sectors and stocks 

```{r, message=FALSE}
# function to fetch all the information for one ticker into a nice xts dataframe 
sp500_stocks <- lapply(sector_list, 
                       f_fetch_all_tickers, 
                       start_date="2016-01-01",
                       end_date="2022-12-01") 
```

```{r}
# Show the available sectors 
names(sp500_stocks)
```

```{r}
# Show available stocks for Industrials 
names(sp500_stocks$Industrials)
```

```{r}
# access the xts of the stocks in industrials 
tail(sp500_stocks$Industrials$ADP)
```


# BACKTESTING LOGIC

### Adding a numeric index

First, we need to create a corresponding index for each week: 

```{r}
# count number of weeks in data from one of the dataframes 
sample_xts <- sp500_stocks$Industrials$CSX
tail(sample_xts, 10)
```

```{r}
sample_xts[, c( "month_index")]
```

## BACKTESTING_PROCEDURE

1. Assume we have $N_{years}$ years of weekly data, giving a total of $N_{months}$ many months. 2. We want to fix a window of $N_{W} = 12$ months at the time (i.e. a year of data). 
3. The total number of runs is given by 

$$
N^{runs} = \left\lfloor 
    \dfrac{N_{months} - N_W}{s} 
\right\rfloor
+ 1 
$$
, where $s=1$ is the number of months to move at the time (because of monthly rebalance). 


i.e., we can move $N^{runs}$ times when predicting one month at the time, starting with having all the data until month 12. 

That is, $\tau = 1, \dots, 48$

```{r}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_best_stocks <- 3 # new strategy: 3x2 = 6 

# Formula parameters
slide <- 1 
N_months <- length(names(split.xts(sample_xts, f= "months")))
N_window <- 24 # number of months in size for each window 
N_runs <- floor((N_months - N_window)/slide)

# display parameters
print(paste0("N_months: ", N_months))
print(paste0("N_runs: ", N_runs))
print(paste0("slide: ", slide))

# setup initial portfolio tracking variables 
initial_capital <- 500000
num_tickers <- length(sectors)*N_sector_best_stocks*2 # two sub-strategies for picking
initial_tickers <- rep(NA, num_tickers)
weights <- rep(1/num_tickers, num_tickers) # initialize to 1/n
returns <- rep(NA, N_runs)

# repack the portfolio 
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns, 
                  data = NA
                  )
portfolio
```

```{r}
# Initiate backtesting 
print(paste(rep("-", 100), collapse = ""))
print("BACKTESTING")
print(paste(rep("-", 100), collapse = ""))
print("")

# for every run (sliding window of time to consider)  
for(tau in seq(N_runs)){
  # close any positions 
  print("###############")
  print(paste0("### (tau=", tau, ") ###"))
  print("###############")
  print("CLOSE all positions")
  
  # Calculate and record profit-loss 
  print("(1) COMPUTE_P/L(portfolio)")
  portfolio$capital <- portfolio$capital * (1 + runif(1, -0.05, 0.10))
  print(paste0("--> Capital:", portfolio$capital, "$"))

  # variables
  i_sector <- 1 # keep index counter for sectors 
  num_top_pick <- N_sector_best_stocks*2 # number of stocks picked per sector
  
  # current portf 
  cur_tickers <- rep(NA, num_tickers)
  
  print("")
  print("(2) PORTFOLIO_LOOP:")
  # loop through all the sectors 
  for(G in sectors){
    # execute sector procedure 
    print(paste0("    SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
    
    # return top 3 best stocks according to procedure 
    top_sector_stocks <- sample(names(sp500_stocks[[G]]), num_top_pick)
    
    # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
    i_replace <- rep(i_sector, num_top_pick) + seq(0, num_top_pick-1) # indexes to choose from
    cur_tickers[i_replace] <- top_sector_stocks
    i_sector <- i_sector + num_top_pick
  }

  # Assign tickers for this simulation
  portfolio$tickers <- as.vector(cur_tickers)
  
  # Display selected portfolio tickers
  print("Cur Portfolio:")
  print(portfolio$tickers)
  
  # Optimize portfolio weights using modified min_variance 
  print("")
  print("(3) OPTIMIZE_PORTFOLIO(portfolio)")
  # simulate the optimization 
  portfolio$weights <- runif(length(portfolio$weights)) / sum(runif(length(portfolio$weights)))
  print("weights: ") 
  print(paste(" ", portfolio$weights))
  
  print("")
  print("(4) LONG PORTFOLIO()")
  
  # Separate similuation (over)
  print(paste(rep("-", 100), collapse = ""))
  
  # TEST: Just for this small printing simulation !!
  if(tau > 4){
    break
  }
}
```


## SECTOR_PROCEDURE

1. Sector $G$ contains tickers $\{S_1,S_1,\dots,  S_{|G|}\}$, where $|G|$= number of stocks per sector (before selection). 
2. For each ticker, want to calculate **current window:**

$$
\left[
  t_1 = \text{week } W_{s\times\tau}
  \;,\;
  t_{12} = \text{week } W_{s\times\tau + 11}
\right]
$$ 

e.g. with $s=1$ (slide one month at the time)

$$
\begin{cases}
\tau = 1 \implies [t_1 = W_{1} \;,\; t_{12} = W_{12}] \\ 
\tau = 2 \implies [t_1 = W_{2} \;,\; t_{12} = W_{13}] \\ 
\vdots \\ 
\tau = i \implies [t_1 = W_{i} \;,\; t_{12} = W_{i+11}] \\ 
\vdots \\ 
\tau = T \implies [t_1 = W_{T-12} \;,\; t_{12} = W_{T}]
\end{cases}
$$



### EXTRACT_STATIC_FEATURES() 

We had a set of features for some stock: 


```{r}
# sample stock dataframe
sample_xts <- sp500_stocks$Industrials$ADP
head(sample_xts, 5)
```


```{r}
# source the feature engineering file 
library("here")
source(here("functions", "feature_engineering.R"))

# test out for a sample run  
tau = 3 # suppose we're at run number 3
sample_xts_train_val <- f_extract_train_val_features(sample_xts, # stock xts
                                                     tau=tau, # current run 
                                                     n_months = N_window, # size of window 
                                                     val_lag = 1 # validation month
                                                     ) 

# display some columns for the extracted data
head(sample_xts_train_val$train[,c("direction_lead", "clv", "volat", "month_index")]) 
print("")
head(sample_xts_train_val$val[,c("direction_lead", "clv", "volat", "month_index")])
```



## EXTRACT_DYNAMIC_FEATURES 

```{r, message=FALSE}
# add GARCH features only 
sample_xts_with_garch <- f_add_garch_forecast(sample_xts, volat_col="volat")

# display 
tail(sample_xts_with_garch, 3)
```

```{r, message=FALSE}
# Example usage
sample_xts_with_arima <- f_add_arima_forecast(sample_xts_with_garch, 
                                              return_col="realized_returns")
tail(sample_xts_with_arima)
```

```{r}
sample_xts_with_arima[, c("actual_returns", "vol_forecast")]
```

```{r}
# Example usage
sample_xts_full <- f_extract_dynamic_features(sample_xts_with_garch, 
                                              return_col="realized_returns")
tail(sample_xts_full)
```


## SECTOR PROCEDURE 


```{r, warning=FALSE}
SECTOR_PROCEDURE <- function(G, tau){ 
  ## 
  ## Params: 
  ##  - G (str): Economic sector name; will be used to fetch the  List of lists 
  ## which are the pre-selected stocks for that sector.
  ##  - tau (numeric): Integer that corresponds to the actual run of the backtest. 
  ## 
  
  
  ### TEST ### 
  # NOTE: For testing only, will be removed later! 
  num_top_pick <- N_sector_best_stocks*2 # number of stocks picked per sector
  ### TEST ### 
  
  print(paste0("SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
  
  # retrieve sector data 
  sector_data <- sp500_stocks[[G]]
  
  # stocks for sector provided 
  sector_tickers <- names(sector_data)
  
  # to store subset features for window 
  sector_stocks_window <- rep(NA, length(sector_tickers)) 
  names(sector_stocks_window) <- sector_tickers
  
  # extract static train-val for all stocks 
  list_train_val_sector <- lapply(sector_data, 
                                  f_extract_train_val_features, 
                                  tau=tau, # current run 
                                  n_months = 12, # size of window 
                                  val_lag = 1 # months to use in val set 
                                  )
  
  # return top 3 best stocks according to modelling procedure
  print("  MODELLING_PROCEDURE(list_train_val_sector)")
  top_sector_stocks <- sample(names(sp500_stocks[[G]]), num_top_pick) 
  
  ########## Inside MODELLING_PROCEDURE #########################
  ### NOTE: The MODELLING_PROCEDURE internally will use the train and 
  
  # Stack the train and val splitted data for all stocks in sector
  sector_stocks <- lapply(list_train_val_sector, function(stock) {
    # Concatenate 'train' and 'val' xts objects within each stock
    concatenated_xts <- rbind(stock$train, stock$val)
    return(concatenated_xts)
  })
  
  # NOTE: MODELLLING_PROCEDURE should also compute dynamic features for concatenated data 
  sector_stocks <- lapply(sector_stocks, f_extract_dynamic_features)
  
  # should return the train-val list for the chosen stocks 
  chosen_stocks <- sector_stocks[names(sector_stocks) %in% top_sector_stocks]
  
  ########## Inside MODELLING_PROCEDURE #########################

  return(chosen_stocks) # not actual return value!
}

# peform the sector procedure 
G = names(sp500_stocks)[[1]]
tau = 5
sector_stocks_window <- SECTOR_PROCEDURE(G, tau)
```

```{r}
names(sector_stocks_window) # names are tickers, values are list of train-val xts
head(sector_stocks_window[[2]]) # show ticker xts
```

# MODELLING_PROCEDURE 

```{r}
# parameters 
G <- names(sp500_stocks)[1] # sample sector 
tau <- 1 # suppose we are in run 5 of the backtest 

####### Inside SECTOR_PROCEDURE ######## 

# retrieve sector data 
sector_data <- sp500_stocks[[G]]

# stocks for sector provided 
sector_tickers <- names(sector_data)

# to store subset features for window 
sector_stocks_window <- rep(NA, length(sector_tickers)) 
names(sector_stocks_window) <- sector_tickers

# extract static train-val for all stocks 
list_train_val_sector <- lapply(sector_data, 
                                f_extract_train_val_features, 
                                tau=tau, # current run 
                                n_months = N_window, # size of window 
                                val_lag = 1 # months to use in val set 
                                )

####### Inside SECTOR_PROCEDURE ########

# keys are stock tickers for that sector 
names(list_train_val_sector)

# each stock has train and test 
names(list_train_val_sector[[1]])
```
```{r}
# Check some of train and val data for one stock 
head(list_train_val_sector[[1]]$train, 3) 
print("")
tail(list_train_val_sector[[1]]$val, 3)
print("") 
nrow(list_train_val_sector[[1]]$train) 
nrow(list_train_val_sector[[1]]$val)
```

We have 46 observations (weeks) for train, and 4 (weeks) for val. 

```{r}
print(head(list_train_val_sector[[1]]$train$month_index, 1)) # beginning month of window 
print(tail(list_train_val_sector[[1]]$val$month_index, 1)) # end month of window
length(seq(5, 16)) # 12 months
```

### Feature Selection 

Only on the `train_set`. 

```{r}
# Extract a sample stock in the list_train_val_sector
sample_sector_stock <- list_train_val_sector[[1]]

# Define the formula for regression
fmla <- realized_returns ~ . -realized_returns -month_index

# try obtaining best features for a sample train set for a stock in the sample sector 
best_feat_list <- f_select_features(
                  fmla = fmla, # formula for regression 
                  data = sample_sector_stock$train, # train data for one stock of current sector  
                  target_var = "realized_returns", # y 
                  volat_col = "volat", 
                  nvmax = 50, # examine all possible subsets
                  method="forward")
best_feat_list
```


### Regularized MLR (Elasticnet) 

$$
\mathcal{L}(\beta) 
= 
\dfrac{1}{2}
\sum_{i=1}^{n}(y_i - x_{i}^T\beta)^{2}
+ 
\lambda\left[
  \alpha ||\beta||_1 
  + (1-\alpha)||\beta||_{2}^{2}
\right]
$$
```{r, message=FALSE}
# load required libraries 
library("caret")
library("Metrics")

# Define the formula for regression
fmla <- realized_returns ~ . -realized_returns -month_index

# Create a grid for elastic net regression hyperparameters
grid_enet <- expand.grid(alpha = seq(from = 0, to = 1, by = 0.1),  # Elastic net mixing parameter
                         lambda = seq(from = 0, to = 0.05, by = 0.001))  # Regularization strength

# Initialize variable to save forecasted returns, MSEs and Sharpe Ratios 
sector_tracker <- as.list(rep(NA, length(sector_tickers)))
names(sector_tracker) <- sector_tickers

# transform into a list of lists 
sector_tracker <- lapply(sector_tracker, function(x) list(
  forecasted_ret = NA,
  sharpe = NA,
  msr = NA, # modified sharpe ratio
  rmse = NA,
  data = NA
))

# display values 
fmla # all initial variables 
names(sector_tracker) # list of lists 
names(sector_tracker[[1]]) # to store the values as the loop happens
```


```{r, message=FALSE, warning=FALSE}
# Loop for every stock ticker in sector G 
for(ticker in sector_tickers){
  print(paste0("ticker: ", ticker))
  
  # fetch data for that ticker 
  ticker_data_train <- list_train_val_sector[[ticker]]$train 
  ticker_data_val <- list_train_val_sector[[ticker]]$val
  
  # remove nas 
  ticker_data_train <- na.omit(ticker_data_train) # data cannot contain nas 
  ticker_data_val <- na.omit(ticker_data_val) # data cannot contain nas 
  
  ### Step 1: Feature Selection 
  
  # Perform feature selection for that stock 
  best_feat_list <-f_select_features(
                      fmla = fmla, # formula for regression 
                      data = ticker_data_train, # train data for one stock of current sector  
                      target_var = "realized_returns", # y 
                      nvmax = 50, 
                      method="forward")
  
  print(c(best_feat_list$fmla))
  
  ### Step 2: Elasticnet 
  
  # Set up time-slice cross-validation parameters
  ctr_train <- trainControl(method = "timeslice",
                            initialWindow = 52,  # Consecutive number of weeks ~= 6 months
                            horizon = 4,         # Horizon is one month prediction (4 weeks)
                            skip = 1,            # No skip, our data will overlap in practice
                            fixedWindow = TRUE,   # Use a fixed window
                            allowParallel = TRUE) # Enable parallel processing
  
  # Stack together train and val, since enet will cross-validate inside 
  full_train <- rbind.xts(ticker_data_train, ticker_data_val)

  # Train the elastic net regression model using time-slice cross-validation
  model_enet_best <- train(form = best_feat_list$fmla,            # Formula from feature selection
                           data = ticker_data_train,              # Training data 
                           method = "glmnet",                     # Model method
                           tuneGrid = grid_enet,                  # Hyperparameter grid
                           trControl = ctr_train,                 # Cross-validation control
                           preProc = c("center", "scale"),        # Preprocessing steps
                           metric = "Rsquared",                   # Metric for selecting the best model
                           threshold = 0.2)
  
  # Extract the best alpha and beta fitted
  best_alpha <- model_enet_best$bestTune$alpha
  best_lambda <- model_enet_best$bestTune$lambda

  # Use the best-fitted elastic net regression model to make predictions on the val_data
  pred_enet_best <- predict(model_enet_best, ticker_data_val) # predict on val 
  pred_enet_best <- mean(pred_enet_best) # take the average
  sector_tracker[[ticker]]$forecasted_ret <- pred_enet_best # save in tracker
  
  # Compute the RMSE on the validation set 
  enet_rmse <- sqrt(mse(actual =ticker_data_val[, "realized_returns"], predicted = pred_enet_best))
  
  print("")
  print(paste("predicted return: ", pred_enet_best))
  print(paste("rmse: ", enet_rmse))
  
  
  print("##########################################")
}
```


## Aside: Format for Portfolio Optimization 


```{r}
## This chunk of code simply obtains some portfolio stock tickers
## in a way that will be similar to the final result 

# repack the portfolio (repeated from before)
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns, 
                  data = NA
                  )
portfolio
```

The following simulates best tickers that would be obtained after modelling procedure for all sectors

```{r, warning=FALSE}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_best_stocks <- 3 
tau <- 3 

# store ticker for current portfolio 
cur_tickers <- rep(NA, num_tickers)

# store actual data for each run 
portf_stocks_data <- as.list(rep(NA, length(sectors)))
names(portf_stocks_data) <- sectors

# keep index counter for sectors 
i_sector <- 1

print("")
print("(2) PORTFOLIO_LOOP:")
# loop through all the sectors 
for(G in sectors){
  
  # return top 3 best stocks (xts data) according to procedure 
  top_sector_stocks <- SECTOR_PROCEDURE(G, tau)

  # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
  i_replace <- rep(i_sector, num_top_pick) + seq(0, num_top_pick-1) # indexes to choose from
  cur_tickers[i_replace] <- names(top_sector_stocks)
  i_sector <- i_sector + num_top_pick
  
  # assign the data to the portfolio 
  portf_stocks_data[[G]] <- top_sector_stocks
}

# Portfolio tickers get updated 
portfolio$tickers <- cur_tickers
```

```{r}
# unlist data best stocks data format into a singles list
portf_data <- f_unlist_portf_data(portf_stocks_data)

# assign list to portfolio 
portfolio$data <- portf_data
```


### Data format for portfoli optimization 

Note that at this point, the portfolio will have the tickers and the weights attributes. 

```{r}
# Checko out the resulting portfolio 
portfolio$tickers
portfolio$capital
portfolio$returns
print("")
```

```{r}
# inspect the names and data for one stock 
names(portfolio$data)
head(portfolio$data[[1]])
```













