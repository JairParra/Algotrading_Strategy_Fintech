---
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[CO,CE]{Hair Parra}
  - \fancyfoot[CO,CE]{Notes by Hair Parra}
  - \fancyfoot[LE,RO]{\thepage}
title: "Strategy Design (ML Fin Data - Project 1)"
author: "Hair Albeiro Parra Barrera"
geometry: margin=1.3cm
always_allow_html: true
output: 
    pdf_document: 
      extra_dependencies: ["array", "amsmath","booktabs"]
---

\newtheorem{assumption}{Assumption}[assumption]
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\newtheorem{remark*}{Remark}
\newtheorem{aside*}{Aside}
\newtheorem{exercise*}{Exercise}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=6) 

# configurations for plot 
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)
```

## Libraries 

```{r, echo=FALSE, message=FALSE}
# Load the required packages
library(TTR) 
library(here)
library(rvest)
library(dplyr)
library(quantmod)
library(tidyverse)
library(tidyquant)
```


# 0. Scraping the SP500

In order to test the logic within the strategy, I have fetched functions that retrieve a number of sample stocks by sector from the SP500. 

```{r}
# to obtain relative paths
library(here)

# Load code into environment 
source(here("functions", "fetch_sp500_sectors.R"))
```


### 0.0.1 SP500 Economic Sectors

The following function fetches and extract the economic sectors from the SP500, taken from [Wikipedia](https://en.wikipedia.org/wiki/List_of_S%26P_500_companies). 


```{r, message=FALSE}
# fetch the sectors as a dataframe 
sp500_sectors <- f_get_sp500_sectors()
head(sp500_sectors)
```


### 0.0.2 SP500 Sector Weight


```{r}
# wrap into a single argument funciton 
fetch_sp500_sector_data <- function(x){f_fetch_sector_data(x, sp500, sp500_sectors)}

# call the function 
head(fetch_sp500_sector_data("Information Technology"))
```

### 0.0.3 Retrieving top sectors and stocks 

Pack everything into one function to retrieve all the data 

```{r}
# Retrieve top 10 stocks by weight for each sector in the top 5 sectors from the SP500 (by weight)
sector_list <- f_retrieve_top_sp500(top_n_sectors = 6, top_n_stocks = 15, only_tickers=TRUE)
sector_list
```
This logic is implemented under **functions/fetch_sp500_sectors.R**


### 0.0.4 Retrieving top sectors and stocks 

```{r, message=FALSE}
# function to fetch all the information for one ticker into a nice xts dataframe 
sp500_stocks <- lapply(sector_list, 
                       f_fetch_all_tickers, 
                       start_date="2018-01-01",
                       end_date="2022-12-01") 
```

```{r}
# Show the available sectors 
names(sp500_stocks)
```
```{r}
# Show available stocks for Industrials 
names(sp500_stocks$Industrials)
```

```{r}
# access the xts of the stocks in industrials 
head(sp500_stocks$Industrials$ADP)
```



# 1. Backtesting Logic 

### Adding a numeric index

First, we need to create a corresponding index for each week: 

```{r}
# count number of weeks in data from one of the dataframes 
sample_xts <- sp500_stocks$Industrials$CSX
tail(sample_xts, 10)
```

```{r}
# month index are assigned automatically 
sample_xts[, c( "month_index")]
```

### splitting data by week 

Initially, the idea was to split week-by-week, however, since we have to rebalance everymonth, this might lead to inconsistent results. Therefore, here I'm splitting the data week by week: 

```{r}
library(xts)

# spli by months 
sample_xts_by_month <- split.xts(sample_xts, f= "months")
names(sample_xts_by_month)
length(names(sample_xts_by_month)) # total number of months of data
```
## BACKTESTING_PROCEDURE

1. Assume we have $N_{years}$ years of weekly data, giving a total of $N_{months}$ many months. 2. We want to fix a window of $N_{W} = 12$ months at the time (i.e. a year of data). 
3. The total number of runs is given by 

$$
N^{runs} = \left\lfloor 
    \dfrac{N_{months} - N_W}{s} 
\right\rfloor
+ 1 
$$
, where $s=1$ is the number of months to move at the time (because of monthly rebalance). 

In our case, this gives 

$$
N^{runs} = \left\lfloor 
    \dfrac{59 - 12}{1} 
\right\rfloor
+ 1 
= 48 
$$
i.e., we can move 47 times when predicting one month at the time, starting with having all the data until month 12. 

That is, $\tau = 1, \dots, 48$

```{r}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_best_stocks <- 3 

# Formula parameters
slide <- 1 
N_months <- length(names(split.xts(sample_xts, f= "months")))
N_window <- 12 # number of months in size for each window 
N_runs <- floor((N_months - N_window)/slide)

# setup initial portfolio tracking variables 
initial_capital <- 500000
num_tickers <- length(sectors)*N_sector_best_stocks
initial_tickers <- rep(NA, num_tickers)
weights <- rep(1/num_tickers, num_tickers) # initialize to 1/n
returns <- rep(NA, N_runs)

# repack the portfolio 
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns
                  )
portfolio
```

```{r}
# Initiate backtesting 
print(paste(rep("-", 100), collapse = ""))
print("BACKTESTING")
print(paste(rep("-", 100), collapse = ""))
print("")

# for every run (sliding window of time to consider)  
for(tau in seq(N_runs)){
  # close any positions 
  print(paste0("(tau=", tau, ") CLOSE all positions."))
  
  # Calculate and record profit-loss 
  print("(1) COMPUTE_P/L(portfolio)")
  portfolio$capital <- portfolio$capital * (1 + runif(1, -0.05, 0.10))
  print(paste0("--> Capital:", portfolio$capital, "$"))

  # keep index counter for sectors 
  i_sector <- 1
  
  # current portf 
  cur_tickers <- rep(NA, num_tickers)
  
  print("")
  print("(2) PORTFOLIO_LOOP:")
  # loop through all the sectors 
  for(G in sectors){
    # execute sector procedure 
    print(paste0("    SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
    
    # return top 3 best stocks according to procedure 
    top_sector_stocks <- sample(names(sp500_stocks[[G]]), 3 )
    
    # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
    i_replace <- c(i_sector, i_sector+1, i_sector+2)
    cur_tickers[i_replace] <- top_sector_stocks
    i_sector <- i_sector + 3
  }

  # Assign tickers for this simulation
  portfolio$tickers <- as.vector(cur_tickers)
  
  # Display selected portfolio tickers
  print("Cur Portfolio:")
  print(portfolio$tickers)
  
  # Optimize portfolio weights using modified min_variance 
  print("")
  print("(3) OPTIMIZE_PORTFOLIO(portfolio)")
  print("weights: ") 
  print(paste(" ", portfolio$weights))
  print("")
  print("(4) LONG PORTFOLIO()")
  
  # Separate similuation (over)
  print(paste(rep("-", 100), collapse = ""))
}
```


## SECTOR_PROCEDURE

1. Sector $G$ contains tickers $\{S_1,S_1,\dots,  S_{|G|}\}$, where $|G|$= number of stocks per sector (before selection). 
2. For each ticker, want to calculate **current window:**

$$
\left[
  t_1 = \text{week } W_{s\times\tau}
  \;,\;
  t_{12} = \text{week } W_{s\times\tau + 11}
\right]
$$ 

e.g. with $s=1$ (slide one month at the time)

$$
\begin{cases}
\tau = 1 \implies [t_1 = W_{1} \;,\; t_{12} = W_{12}] \\ 
\tau = 2 \implies [t_1 = W_{2} \;,\; t_{12} = W_{13}] \\ 
\vdots \\ 
\tau = i \implies [t_1 = W_{i} \;,\; t_{12} = W_{i+11}] \\ 
\vdots \\ 
\tau = 48 \implies [t_1 = W_{48} \;,\; t_{12} = W_{59}]
\end{cases}
$$



### EXTRACT_STATIC_FEATURES() 

We had a set of features for some stock: 


```{r}
# sample stock dataframe
sample_xts <- sp500_stocks$Industrials$ADP
head(sample_xts, 5)
```


```{r}
# source the feature engineering file 
library("here")
source(here("functions", "feature_engineering.R"))

# test out for a sample run  
tau = 3 # run number 3
sample_xts_train_val <- f_extract_train_val_features(sample_xts, tau=tau) # extract features

# display some columns for the extracted data
head(sample_xts_train_val$train[,c("direction_lead", "clv", "volat", "month_index")]) 
print("")
head(sample_xts_train_val$val[,c("direction_lead", "clv", "volat", "month_index")])
```


### SECTOR PROCEDURE 

```{r}
SECTOR_PROCEDURE <- function(G, tau){ 
  ## 
  ## Params: 
  ##  - G (str): Economic sector name; will be used to fetch the  List of lists 
  ## which are the pre-selected stocks for that sector.
  ##  - tau (numeric): Integer that corresponds to the actual run of the backtest. 
  ## 
  
  print(paste0("SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
  
  # retrieve sector data 
  sector_data <- sp500_stocks[[G]]
  
  # stocks for sector provided 
  sector_tickers <- names(sector_data)
  
  # to store subset features for window 
  sector_stocks_window <- rep(NA, length(sector_tickers)) 
  names(sector_stocks_window) <- sector_tickers
  
  # extract static train-val for all stocks 
  list_train_val_sector <- lapply(sector_data, f_extract_train_val_features, tau=tau)
  
  # return top 3 best stocks according to modelling procedure
  print("  MODELLING_PROCEDURE()")
  top_sector_stocks <- sample(names(sp500_stocks[[G]]), 3 )

  return(list_train_val_sector) # not actual return value!
  # return(top_sector_stocks)
}

# peform the sector procedure 
G = names(sp500_stocks)[[1]]
tau = 5
sector_stocks_window <- SECTOR_PROCEDURE(G, tau)
```

```{r}
names(sector_stocks_window) # names are tickers, values are list of train-val xts
names(sector_stocks_window$ADP) # names are train and val, value for each are xts
head(sector_stocks_window$CAT$train, 3) # xts object subset
print("") 
tail(sector_stocks_window$CAT$val, 3)
```
## EXTRACT_DYNAMIC_FEATURES 

```{r}
# add GARCH features only 
sample_xts_with_garch <- f_add_garch_forecast(sample_xts, volat_col="volat")

# display 
tail(sample_xts_with_garch, 3)
```

```{r}
# Example usage
sample_xts_with_arima <- f_add_arima_features(sample_xts_with_garch, 
                                              return_col="realized_returns")
tail(sample_xts_with_arima)
```

### Adding the dynamic features to any stock xts subset

```{r}
# add all the features to the sample data 
sample_xts_full_feats <- f_extract_dynamic_features(sample_xts) 
head(sample_xts_full_feats)
```


















