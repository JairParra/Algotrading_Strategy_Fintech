---
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[CO,CE]{Hair Parra}
  - \fancyfoot[CO,CE]{Notes by Hair Parra}
  - \fancyfoot[LE,RO]{\thepage}
title: "Strategy Design (ML Fin Data - Project 1)"
author: "Hair Albeiro Parra Barrera"
geometry: margin=1.3cm
always_allow_html: true
output: 
    pdf_document: 
      extra_dependencies: ["array", "amsmath","booktabs"]
---

\newtheorem{assumption}{Assumption}[assumption]
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\newtheorem{remark*}{Remark}
\newtheorem{aside*}{Aside}
\newtheorem{exercise*}{Exercise}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=6) 

# configurations for plot 
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)
```

## Libraries 

```{r, echo=FALSE, message=FALSE}
# Load the required packages
library(TTR) 
library(here)
library(rvest)
library(dplyr)
library(quantmod)
library(tidyverse)
library(tidyquant)
```


# 0. Scraping the SP500

In order to test the logic within the strategy, I have fetched functions that retrieve a number of sample stocks by sector from the SP500. 

```{r}
# to obtain relative paths
library(here)

# Load code into environment 
source(here("functions", "fetch_sp500_sectors.R"))
```


### 0.0.1 SP500 Economic Sectors

The following function fetches and extract the economic sectors from the SP500, taken from [Wikipedia](https://en.wikipedia.org/wiki/List_of_S%26P_500_companies). 


```{r, message=FALSE}
# fetch the sectors as a dataframe 
sp500_sectors <- f_get_sp500_sectors()
head(sp500_sectors)
```


### 0.0.2 SP500 Sector Weight


```{r}
# wrap into a single argument funciton 
fetch_sp500_sector_data <- function(x){f_fetch_sector_data(x, sp500, sp500_sectors)}

# call the function 
head(fetch_sp500_sector_data("Information Technology"))
```

### 0.0.3 Retrieving top sectors and stocks 

Pack everything into one function to retrieve all the data 

```{r}
# Retrieve top 10 stocks by weight for each sector in the top 5 sectors from the SP500 (by weight)
sector_list <- f_retrieve_top_sp500(top_n_sectors = 6, top_n_stocks = 15, only_tickers=TRUE)
sector_list
```
This logic is implemented under **functions/fetch_sp500_sectors.R**


### 0.0.4 Retrieving top sectors and stocks 

```{r, message=FALSE}
# function to fetch all the information for one ticker into a nice xts dataframe 
sp500_stocks <- lapply(sector_list, 
                       f_fetch_all_tickers, 
                       start_date="2018-01-01",
                       end_date="2022-12-01") 
```

```{r}
# Show the available sectors 
names(sp500_stocks)
```
```{r}
# Show available stocks for Industrials 
names(sp500_stocks$Industrials)
```

```{r}
# access the xts of the stocks in industrials 
head(sp500_stocks$Industrials$ADP)
```

# 1. Backtesting Logic 

### Adding a numeric index

First, we need to create a corresponding index for each week: 

```{r}
# count number of weeks in data from one of the dataframes 
sample_xts <- sp500_stocks$Industrials$ADP
head(sample_xts, 10)
```

```{r}
# month index are assigned automatically 
sample_xts[, c( "month_index")]
```

### splitting data by week 

Initially, the idea was to split week-by-week, however, since we have to rebalance everymonth, this might lead to inconsistent results. Therefore, here I'm splitting the data week by week: 

```{r}
library(xts)

# spli by months 
sample_xts_by_month <- split.xts(sample_xts, f= "months")
names(sample_xts_by_month)
length(names(sample_xts_by_month)) # total number of months of data
```
## BACKTESTING_PROCEDURE

1. Assume we have $N_{years}$ years of weekly data, giving a total of $N_{months}$ many months. 2. We want to fix a window of $N_{W} = 12$ months at the time (i.e. a year of data). 
3. The total number of runs is given by 

$$
N^{runs} = \left\lfloor 
    \dfrac{N_{months} - N_W}{s} 
\right\rfloor
$$
, where $s=1$ is the number of months to move at the time (because of monthly rebalance). 

In our case, this gives 

$$
N^{runs} = \left\lfloor 
    \dfrac{59 - 12}{1} 
\right\rfloor
= 47 
$$
i.e., we can move 47 times when predicting one week at the time, starting with having all the data until month 12. 

```{r}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_stocks <- 3 # 

# Formula parameters
slide <- 1 
N_months <- length(names(split.xts(sample_xts, f= "months")))
N_window <- 12 # number of months in size for each window 
N_runs <- floor((N_months - N_window)/slide)

# setup initial portfolio tracking variables 
initial_capital <- 500000
num_tickers <- length(sectors)*N_sector_stocks
initial_tickers <- rep(NA, num_tickers)
weights <- rep(1/num_tickers, num_tickers) # initialize to 1/n
returns <- rep(NA, N_runs)

# repack the portfolio 
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns
                  )
portfolio
```

```{r}

# Initiate backtesting 
print(paste(rep("-", 100), collapse = ""))
print("BACKTESTING")
print(paste(rep("-", 100), collapse = ""))
print("")

# for every run (sliding window of time to consider)  
for(tau in seq(N_runs)){
  # close any positions 
  print(paste0("(tau=", tau, ") CLOSE all positions."))
  
  # Calculate and record profit-loss 
  print("(1) COMPUTE_P/L(portfolio)")
  portfolio$capital <- portfolio$capital * (1 + runif(1, -0.05, 0.10))
  print(paste0("--> Capital:", portfolio$capital, "$"))

  # keep index counter for sectors 
  i_sector <- 1
  
  # current portf 
  cur_tickers <- rep(NA, num_tickers)
  
  print("")
  print("(2) PORTFOLIO_LOOP:")
  # loop through all the sectors 
  for(G in sectors){
    # execute sector procedure 
    print(paste0("    SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
    
    # return top 3 best stocks according to procedure 
    top_sector_stocks <- sample(names(sp500_stocks[[G]]), 3 )
    
    # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
    i_replace <- c(i_sector, i_sector+1, i_sector+2)
    cur_tickers[i_replace] <- top_sector_stocks
    i_sector <- i_sector + 3
  }

  # Assign tickers for this simulation
  portfolio$tickers <- as.vector(cur_tickers)
  
  # Display selected portfolio tickers
  print("Cur Portfolio:")
  print(portfolio$tickers)
  
  # Optimize portfolio weights using modified min_variance 
  print("")
  print("(3) OPTIMIZE_PORTFOLIO(portfolio)")
  print("weights: ") 
  print(paste(" ", portfolio$weights))
  print("")
  print("(4) LONG PORTFOLIO()")
  
  
  # Separate similuation (over)
  print(paste(rep("-", 100), collapse = ""))
}
```








