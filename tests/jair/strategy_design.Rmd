---
header-includes:
  - \usepackage{amsmath}
  - \usepackage{amssymb}
  - \usepackage{amsthm}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhead[CO,CE]{Hair Parra}
  - \fancyfoot[CO,CE]{Notes by Hair Parra}
  - \fancyfoot[LE,RO]{\thepage}
title: "Strategy Design (ML Fin Data - Project 1)"
author: "Hair Albeiro Parra Barrera"
geometry: margin=1.3cm
always_allow_html: true
output: 
    pdf_document: 
      extra_dependencies: ["array", "amsmath","booktabs"]
---

\newtheorem{assumption}{Assumption}[assumption]
\newtheorem{theorem}{Theorem}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}
\newtheorem{remark*}{Remark}
\newtheorem{aside*}{Aside}
\newtheorem{exercise*}{Exercise}

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=9, fig.height=6) 

# configurations for plot 
my_plot_hook <- function(x, options)
  paste("\n", knitr::hook_plot_tex(x, options), "\n")
knitr::knit_hooks$set(plot = my_plot_hook)
```

## Libraries 

```{r, echo=FALSE, message=FALSE}
# Load the required packages
library(TTR) 
library(here)
library(rvest)
library(dplyr)
library(quantmod)
library(tidyverse)
library(tidyquant)
```


# 0. Scraping the SP500

In order to test the logic within the strategy, I have fetched functions that retrieve a number of sample stocks by sector from the SP500. 

```{r}
# to obtain relative paths
library(here)

# Load code into environment 
source(here("functions", "fetch_sp500_sectors.R"))
```


### 0.0.1 SP500 Economic Sectors

The following function fetches and extract the economic sectors from the SP500, taken from [Wikipedia](https://en.wikipedia.org/wiki/List_of_S%26P_500_companies). 


```{r, message=FALSE}
# fetch the sectors as a dataframe 
sp500_sectors <- f_get_sp500_sectors()
head(sp500_sectors)
```


### 0.0.2 SP500 Sector Weight


```{r}
# wrap into a single argument funciton 
fetch_sp500_sector_data <- function(x){f_fetch_sector_data(x, sp500, sp500_sectors)}

# call the function 
head(fetch_sp500_sector_data("Information Technology"))
```

### 0.0.3 Retrieving top sectors and stocks 

Pack everything into one function to retrieve all the data 

```{r, message=FALSE, warning=FALSE}
# Retrieve top 10 stocks by weight for each sector in the top 5 sectors from the SP500 (by weight)
sector_list <- f_retrieve_top_sp500(top_n_sectors = 6, top_n_stocks = 15, only_tickers=TRUE)
sector_list
```
This logic is implemented under **functions/fetch_sp500_sectors.R**


### 0.0.4 Retrieving top sectors and stocks 

```{r, message=FALSE}
# function to fetch all the information for one ticker into a nice xts dataframe 
sp500_stocks <- lapply(sector_list, 
                       f_fetch_all_tickers, 
                       start_date="2018-01-01",
                       end_date="2022-12-01") 
```

```{r}
# Show the available sectors 
names(sp500_stocks)
```

```{r}
# Show available stocks for Industrials 
names(sp500_stocks$Industrials)
```

```{r}
# access the xts of the stocks in industrials 
tail(sp500_stocks$Industrials$ADP)
```


# BACKTESTING LOGIC

### Adding a numeric index

First, we need to create a corresponding index for each week: 

```{r}
# count number of weeks in data from one of the dataframes 
sample_xts <- sp500_stocks$Industrials$CSX
tail(sample_xts, 10)
```

```{r}
sample_xts[, c( "month_index")]
```

## BACKTESTING_PROCEDURE

1. Assume we have $N_{years}$ years of weekly data, giving a total of $N_{months}$ many months. 2. We want to fix a window of $N_{W} = 12$ months at the time (i.e. a year of data). 
3. The total number of runs is given by 

$$
N^{runs} = \left\lfloor 
    \dfrac{N_{months} - N_W}{s} 
\right\rfloor
+ 1 
$$
, where $s=1$ is the number of months to move at the time (because of monthly rebalance). 


i.e., we can move $N^{runs}$ times when predicting one month at the time, starting with having all the data until month 12. 

That is, $\tau = 1, \dots, 48$

```{r}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_best_stocks <- 3 

# Formula parameters
slide <- 1 
N_months <- length(names(split.xts(sample_xts, f= "months")))
N_window <- 12 # number of months in size for each window 
N_runs <- floor((N_months - N_window)/slide)

# setup initial portfolio tracking variables 
initial_capital <- 500000
num_tickers <- length(sectors)*N_sector_best_stocks
initial_tickers <- rep(NA, num_tickers)
weights <- rep(1/num_tickers, num_tickers) # initialize to 1/n
returns <- rep(NA, N_runs)

# repack the portfolio 
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns, 
                  data = NA
                  )
portfolio
```

```{r}
# Initiate backtesting 
print(paste(rep("-", 100), collapse = ""))
print("BACKTESTING")
print(paste(rep("-", 100), collapse = ""))
print("")

# for every run (sliding window of time to consider)  
for(tau in seq(N_runs)){
  # close any positions 
  print(paste0("(tau=", tau, ") CLOSE all positions."))
  
  # Calculate and record profit-loss 
  print("(1) COMPUTE_P/L(portfolio)")
  portfolio$capital <- portfolio$capital * (1 + runif(1, -0.05, 0.10))
  print(paste0("--> Capital:", portfolio$capital, "$"))

  # keep index counter for sectors 
  i_sector <- 1
  
  # current portf 
  cur_tickers <- rep(NA, num_tickers)
  
  print("")
  print("(2) PORTFOLIO_LOOP:")
  # loop through all the sectors 
  for(G in sectors){
    # execute sector procedure 
    print(paste0("    SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
    
    # return top 3 best stocks according to procedure 
    top_sector_stocks <- sample(names(sp500_stocks[[G]]), 3 )
    
    # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
    i_replace <- c(i_sector, i_sector+1, i_sector+2)
    cur_tickers[i_replace] <- top_sector_stocks
    i_sector <- i_sector + 3
  }

  # Assign tickers for this simulation
  portfolio$tickers <- as.vector(cur_tickers)
  
  # Display selected portfolio tickers
  print("Cur Portfolio:")
  print(portfolio$tickers)
  
  # Optimize portfolio weights using modified min_variance 
  print("")
  print("(3) OPTIMIZE_PORTFOLIO(portfolio)")
  # simulate the optimization 
  portfolio$weights <- runif(length(portfolio$weights)) / sum(runif(length(portfolio$weights)))
  print("weights: ") 
  print(paste(" ", portfolio$weights))
  
  print("")
  print("(4) LONG PORTFOLIO()")
  
  # Separate similuation (over)
  print(paste(rep("-", 100), collapse = ""))
}
```


## SECTOR_PROCEDURE

1. Sector $G$ contains tickers $\{S_1,S_1,\dots,  S_{|G|}\}$, where $|G|$= number of stocks per sector (before selection). 
2. For each ticker, want to calculate **current window:**

$$
\left[
  t_1 = \text{week } W_{s\times\tau}
  \;,\;
  t_{12} = \text{week } W_{s\times\tau + 11}
\right]
$$ 

e.g. with $s=1$ (slide one month at the time)

$$
\begin{cases}
\tau = 1 \implies [t_1 = W_{1} \;,\; t_{12} = W_{12}] \\ 
\tau = 2 \implies [t_1 = W_{2} \;,\; t_{12} = W_{13}] \\ 
\vdots \\ 
\tau = i \implies [t_1 = W_{i} \;,\; t_{12} = W_{i+11}] \\ 
\vdots \\ 
\tau = 48 \implies [t_1 = W_{48} \;,\; t_{12} = W_{59}]
\end{cases}
$$



### EXTRACT_STATIC_FEATURES() 

We had a set of features for some stock: 


```{r}
# sample stock dataframe
sample_xts <- sp500_stocks$Industrials$ADP
head(sample_xts, 5)
```


```{r}
# source the feature engineering file 
library("here")
source(here("functions", "feature_engineering.R"))

# test out for a sample run  
tau = 3 # run number 3
sample_xts_train_val <- f_extract_train_val_features(sample_xts, # stock xts
                                                     tau=tau, # current run 
                                                     n_months = N_window, # size of window 
                                                     val_lag = 1 # validation month
                                                     ) 

# display some columns for the extracted data
head(sample_xts_train_val$train[,c("direction_lead", "clv", "volat", "month_index")]) 
print("")
head(sample_xts_train_val$val[,c("direction_lead", "clv", "volat", "month_index")])
```

```{r}
# show how the train and validation set look together
rbind(sample_xts_train_val$train[,c("direction_lead", "clv", "volat", "month_index")], 
      sample_xts_train_val$val[,c("direction_lead", "clv", "volat", "month_index")])
```

## EXTRACT_DYNAMIC_FEATURES 

```{r, message=FALSE}
# add GARCH features only 
sample_xts_with_garch <- f_add_garch_forecast(sample_xts, volat_col="volat")

# display 
tail(sample_xts_with_garch, 3)
```

```{r, message=FALSE}
# Example usage
sample_xts_with_arima <- f_add_arima_forecast(sample_xts_with_garch, 
                                              return_col="realized_returns")
tail(sample_xts_with_arima)
```

```{r}
sample_xts_with_arima[, c("actual_returns", "vol_forecast")]
```
```{r}
# Example usage
sample_xts_full <- f_extract_dynamic_features(sample_xts_with_garch, 
                                              return_col="realized_returns")
tail(sample_xts_full)
```


## SECTOR PROCEDURE 


```{r, warning=FALSE}
SECTOR_PROCEDURE <- function(G, tau){ 
  ## 
  ## Params: 
  ##  - G (str): Economic sector name; will be used to fetch the  List of lists 
  ## which are the pre-selected stocks for that sector.
  ##  - tau (numeric): Integer that corresponds to the actual run of the backtest. 
  ## 
  
  print(paste0("SECTOR_PROCEDURE(G=", G, ", tau=",tau, ")"))
  
  # retrieve sector data 
  sector_data <- sp500_stocks[[G]]
  
  # stocks for sector provided 
  sector_tickers <- names(sector_data)
  
  # to store subset features for window 
  sector_stocks_window <- rep(NA, length(sector_tickers)) 
  names(sector_stocks_window) <- sector_tickers
  
  # extract static train-val for all stocks 
  list_train_val_sector <- lapply(sector_data, 
                                  f_extract_train_val_features, 
                                  tau=tau, # current run 
                                  n_months = 12, # size of window 
                                  val_lag = 2 # months to use in val set 
                                  )
  
  # return top 3 best stocks according to modelling procedure
  print("  MODELLING_PROCEDURE(list_train_val_sector)")
  top_sector_stocks <- sample(names(sp500_stocks[[G]]), 3 ) 
  
  ########## Inside MODELLING_PROCEDURE #########################
  
  # Stack the train and val splitted data for all stocks in sector
  sector_stocks <- lapply(list_train_val_sector, function(stock) {
    # Concatenate 'train' and 'val' xts objects within each stock
    concatenated_xts <- rbind(stock$train, stock$val)
    return(concatenated_xts)
  })
  
  # NOTE: MODELLLING_PROCEDURE should also compute dynamic features for concatenated data 
  sector_stocks <- lapply(sector_stocks, f_extract_dynamic_features)
  
  # should return the train-val list for the chosen stocks 
  chosen_stocks <- sector_stocks[names(sector_stocks) %in% top_sector_stocks]
  
  ########## Inside MODELLING_PROCEDURE #########################

  return(chosen_stocks) # not actual return value!
}

# peform the sector procedure 
G = names(sp500_stocks)[[1]]
tau = 5
sector_stocks_window <- SECTOR_PROCEDURE(G, tau)
```

```{r}
names(sector_stocks_window) # names are tickers, values are list of train-val xts
head(sector_stocks_window[[2]]) # names are train and val, value for each are xts
```

## Aside: Format for Portfolio Optimization 


```{r}
## This chunk of code simply obtains some portfolio stock tickers
## in a way that will be similar to the final result 

# repack the portfolio (repeated from before)
portfolio <- list(tickers = initial_tickers, 
                  weights = weights, 
                  capital = initial_capital, 
                  returns = returns, 
                  data = NA
                  )
portfolio
```

The following simulates best tickers that would be obtained after modelling procedure for all sectors

```{r, warning=FALSE}
# Set up backtesting simulation parameters
sample_xts <- sp500_stocks$Industrials$ADP
sectors <- names(sp500_stocks) 
N_sector_best_stocks <- 3 
tau <- 3 

# store ticker for current portfolio 
cur_tickers <- rep(NA, num_tickers)

# store actual data for each run 
portf_stocks_data <- as.list(rep(NA, length(sectors)))
names(portf_stocks_data) <- sectors

# keep index counter for sectors yfu,uyfyu
i_sector <- 1

print("")
print("(2) PORTFOLIO_LOOP:")
# loop through all the sectors 
for(G in sectors){
  
  # return top 3 best stocks (xts data) according to procedure 
  top_sector_stocks <- SECTOR_PROCEDURE(G, tau)

  # assign best stocks to portfolio (NEED TO UPDATE LOGIC!)
  i_replace <- c(i_sector, i_sector+1, i_sector+2)
  cur_tickers[i_replace] <- names(top_sector_stocks)
  i_sector <- i_sector + 3
  
  # assign the data to the portfolio 
  portf_stocks_data[[G]] <- top_sector_stocks
}

# Portfolio tickers get updated 
portfolio$tickers <- cur_tickers
```

```{r}
# unlist data best stocks data format into a singles list
portf_data <- f_unlist_portf_data(portf_stocks_data)

# assign list to portfolio 
portfolio$data <- portf_data
```


### Data format for portfoli optimization 

Note that at this point, the portfolio will have the tickers and the weights attributes. 

```{r}
# Checko out the resulting portfolio 
portfolio$tickers
portfolio$capital
portfolio$returns
print("")

# inspect the names and data for one stock 
names(portfolio$data)
head(portfolio$data[[1]])
```












